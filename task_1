# ------  list comprehensions --------------
# list comprehensions implementation. Receives a list, and returns
# a new list containing the computations.


def p_1_lc(inputlist):
    return [x * 2 + 1 for x in inputlist]


# list comprehensions implementation. Receives a list, and returns
# a new list containing True for mod3=0 values and False otherwise.
def p_2_lc(inputlist):
    return [True if x % 3 == 0 else False for x in inputlist]


# list comprehensions implementation. Receives a list, and returns
# a new list containing the square on each argument in the list.
def p_3_lc(inputlist):
    return [x**2 for x in inputlist]


# list comprehensions implementation. Receives a list, and returns
# a new list containing upper first letter of the original word.
def p_4_lc(inputlist):
    return [x[0].upper() for x in inputlist]


# list comprehensions implementation. Receives a list, and returns
# a new list containing only the words that contains the char 'p'.
def p_5_lc(inputlist):
    return [x for x in inputlist if 'p' in x]


# list comprehensions implementation. Receives a list, and returns
# a new list containing tuple- (original word, len(word)).
def p_6_lc(inputlist):
    return [(x, len(x)) for x in inputlist]


# list comprehensions implementation. Receives a list, and returns
# a new list containing only the odds numbers.
def p_7_lc(inputlist):
    return [x for x in inputlist if x % 2 != 0]


# list comprehensions implementation. Receives a list, and returns
# a new list containing only the odd indexes.
def p_8_lc(inputlist):
    return [x for x in inputlist if inputlist.index(x) % 2 == 0]


# ------  functional operators implementation --------------

# functional operators implementation. Receives a list, and returns
# a new list containing the odd-indexes only.
def p_1_fo(inputlist):
    return list(map(lambda x: x * 2 + 1, inputlist))


# functional operators implementation. Receives a list, and returns
# a new list containing True for mod3=0 values and False otherwise.
def p_2_fo(inputlist):
    return list(map(lambda x: True if x % 3 == 0 else False, inputlist))


# functional operators implementation. Receives a list, and returns
# a new list containing the square on each argument in the list.
def p_3_fo(inputlist):
    return list(map(lambda x: x ** 2, inputlist))


# functional operators implementation. Receives a list, and returns
# a new list containing upper first letter of the original word.
def p_4_fo(inputlist):
    return list(map(lambda x: x[0].upper(), inputlist))


# functional operators implementation. Receives a list, and returns
# a new list containing only the words that contains the char 'p'.
def p_5_fo(inputlist):
    return list(filter(lambda x: 'p' in x, inputlist))


# functional operators implementation. Receives a list, and returns
# a new list containing tuple- (original word, len(word)).
def p_6_fo(inputlist):
    return list(map(lambda x: (x, len(x)), inputlist))


# functional operators implementation. Receives a list, and returns
# a new list containing only the odds numbers.
def p_7_fo(inputlist):
    return list(filter(lambda x: x % 2 != 0, inputlist))


# functional operators implementation. Receives a list, and returns
# a new list containing only the odd indexes.
def p_8_fo(inputlist):
    return list(filter(lambda x: inputlist.index(x) % 2 == 0, inputlist))






